<!DOCTYPE html><html lang="ch" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>THU《操作系统》学习笔记——实验一：bootloader启动ucoreos | J's Blog</title><meta name="keywords" content="操作系统,操作系统实验"><meta name="author" content="Jiang"><meta name="copyright" content="Jiang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="THU《操作系统》学习笔记—— 实验一：bootloader启动ucoreos实验前置理论-1 启动顺序：1.1 x86寄存器初始值&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;计算机在加电之后，寄存器被初始化成上图中的初始值，Intel 80836加电后的第一条指令的地址是段寄存器CS中隐含的Base的值(从第一幅图中可以看到为FFFF0000H)加上EIP中的">
<meta property="og:type" content="article">
<meta property="og:title" content="THU《操作系统》学习笔记——实验一：bootloader启动ucoreos">
<meta property="og:url" content="http://example.com/2021/11/30/os_study_4/index.html">
<meta property="og:site_name" content="J&#39;s Blog">
<meta property="og:description" content="THU《操作系统》学习笔记—— 实验一：bootloader启动ucoreos实验前置理论-1 启动顺序：1.1 x86寄存器初始值&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;计算机在加电之后，寄存器被初始化成上图中的初始值，Intel 80836加电后的第一条指令的地址是段寄存器CS中隐含的Base的值(从第一幅图中可以看到为FFFF0000H)加上EIP中的">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/AVA.jpg">
<meta property="article:published_time" content="2021-11-30T08:16:25.000Z">
<meta property="article:modified_time" content="2022-05-15T13:30:59.537Z">
<meta property="article:author" content="Jiang">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="操作系统实验">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/AVA.jpg"><link rel="shortcut icon" href="/true"><link rel="canonical" href="http://example.com/2021/11/30/os_study_4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'THU《操作系统》学习笔记——实验一：bootloader启动ucoreos',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-15 21:30:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/AVA.jpg" onerror="onerror=null;src='/img/AVA.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/WIF2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">J's Blog</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">THU《操作系统》学习笔记——实验一：bootloader启动ucoreos</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-30T08:16:25.000Z" title="Created 2021-11-30 16:16:25">2021-11-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-05-15T13:30:59.537Z" title="Updated 2022-05-15 21:30:59">2022-05-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">操作系统学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="THU《操作系统》学习笔记——实验一：bootloader启动ucoreos"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="THU《操作系统》学习笔记——-实验一：bootloader启动ucoreos"><a href="#THU《操作系统》学习笔记——-实验一：bootloader启动ucoreos" class="headerlink" title="THU《操作系统》学习笔记—— 实验一：bootloader启动ucoreos"></a>THU《操作系统》学习笔记—— 实验一：bootloader启动ucoreos</h1><h2 id="实验前置理论-1-启动顺序："><a href="#实验前置理论-1-启动顺序：" class="headerlink" title="实验前置理论-1 启动顺序："></a>实验前置理论-1 启动顺序：</h2><h3 id="1-1-x86寄存器初始值"><a href="#1-1-x86寄存器初始值" class="headerlink" title="1.1 x86寄存器初始值"></a>1.1 x86寄存器初始值</h3><p>&amp;emsp;&amp;emsp;<img src="https://i.loli.net/2021/11/27/sG4vl89eLbg2BWy.jpg" alt="x86寄存器初始值"><br><img src="https://i.loli.net/2021/11/27/OS98xRmyZJ5dWut.jpg" alt="第一条指令地址"><br>&amp;emsp;&amp;emsp;计算机在加电之后，寄存器被初始化成上图中的初始值，Intel 80836加电后的第一条指令的地址是段寄存器CS中隐含的Base的值(从第一幅图中可以看到为FFFF0000H)加上EIP中的值(0000FFF0H)，也就是FFFFFFF0H。注意这一块内存地址是BIOS的EPROM(可擦除可编程只读存储器)所在地，是只读的，从这个地址取得第一条指令。这个指令一般是长跳转指令，更新CS和EIP跳到BIOS代码去做初始化工作。目前CPU还处于实模式，寻址能力只有1MB，长跳转指令也是跳到一个可以被访问的1MB内存空间里面执行。</p>
<hr>
<h3 id="1-2-处于实模式的段"><a href="#1-2-处于实模式的段" class="headerlink" title="1.2 处于实模式的段"></a>1.2 处于实模式的段</h3><p>&amp;emsp;&amp;emsp;CS和EIP是一个16位的寄存器，它们相加为什么能形成20位的地址？是在于16位的段寄存器CS左移了四位，左移四位之后再叠加上EIP的值，才形成了实模式下最终的寻址方式。所以CS:IP&#x3D;CS*16+IP。<br><img src="https://i.loli.net/2021/11/27/pnCU9wY1gst68Ok.jpg" alt="寻址方式示意图"></p>
<hr>
<h3 id="1-3-从BIOS到Bootloader"><a href="#1-3-从BIOS到Bootloader" class="headerlink" title="1.3 从BIOS到Bootloader"></a>1.3 从BIOS到Bootloader</h3><p><img src="https://i.loli.net/2021/11/27/sr8JB156xYjPyIo.jpg" alt="BIOS到Bootloader"><br>&amp;emsp;&amp;emsp;一块扇区大小是512字节，BIOS加载存储设备上的第一块扇区到内存0x7c00的地址，然后跳转到0x7c00执行代码，这512字节的代码将会完成后续的加载工作，这个扇区的代码我们称为Bootloader。</p>
<hr>
<h3 id="1-4-从Bootloader到OS"><a href="#1-4-从Bootloader到OS" class="headerlink" title="1.4 从Bootloader到OS"></a>1.4 从Bootloader到OS</h3><p><img src="https://i.loli.net/2021/11/27/cz4gi297SPVkLe6.jpg" alt="从Bootloader到OS"><br>&amp;emsp;&amp;emsp;Bootloader第一件干的事是让CPU从实模式转变为保护模式，这个过程称为使能保护模式。一旦使能了保护模式，那么段机制也就自动加载上来了，段机制也使能了。</p>
<p>&amp;emsp;&amp;emsp;Bootloader第二件事是从存储设备中读取kernel(内核)，它需要把OS的代码读到内存中来。</p>
<p>&amp;emsp;&amp;emsp;Bootloader最后把控制权交给OS去让它进一步执行，怎么交？就是把CS和EIP的值指向内核所在内存地址的起点，跳到这来就相当于把控制权交给了OS。</p>
<hr>
<h3 id="1-5-段机制"><a href="#1-5-段机制" class="headerlink" title="1.5 段机制"></a>1.5 段机制</h3><p><img src="https://i.loli.net/2021/11/27/vPIExqVLhZwt3fb.jpg" alt="段机制示意图"><br>&amp;emsp;&amp;emsp;在段机制中，寄存器起了一个指针的作用，它指向了段描述符，在段描述符里描述了一个段落的起始地址和它的大小。所以可以通过CS里的Selector的值找到OS代码段起始地址在什么地方。<br><img src="https://i.loli.net/2021/11/27/4sv2BeRapKU3bNF.jpg" alt="段机制示意图2"><br>&amp;emsp;&amp;emsp;在一个段寄存器里，会保存一块地址叫段选择址(Seg Selector)，通过它查找段描述符表中的一个段描述符，它们之间也就是一种映射关系。这个段描述符会存着基址(Base Address)和大小，这个起始地址加上Offset(EIP的值)得到线性地址。这个时候还没有启动页机制，线性地址也就等同于物理地址。</p>
<p>&amp;emsp;&amp;emsp;那么如何建立好段机制？很重要的一点就是需要有一个大的数组，把各个段描述符装进去，我们把它称为GDT(Global Descriptor Table 全局描述符表&#x2F;段表)，这个GDT是由Bootloader来建立的。Bootloader会描述好段描述符表的一个大致的空间，然后给出它的位置和大小，然后通过一个特殊的指令就可以让CPU能够找到GDT的首地址。得到这个表的首地址之后呢，通过内部的GDTR寄存器来保存这个首地址，然后使得各个段寄存器可以和GDT建立对应关系。</p>
<p>&amp;emsp;&amp;emsp;前面说到段寄存器一共有16位，其中的高13位放的就是GDT的Index，低位的两位是RPL(Requested Privilege Level),表明这个段的优先级的级别，在x86用了2个bit表示这个值，意味着它可以表示0，1，2，3四个特权级，CPU中的最高级是0，而应用程序会放在3这个特权级里。这个TI一般设置成0，0表示要查的表是GDT，1表示LDT(本地描述符)。</p>
<p>&amp;emsp;&amp;emsp;建立完段机制后，使能保护模式需要靠对控制寄存器CR0设置它的第0位bit为1，之后就意味着CPU进入保护模式，段机制是在保护模式下自动使能的。<br><img src="https://i.loli.net/2021/11/27/7fBIYZExmUPHsWJ.jpg" alt="段机制示意图3"></p>
<hr>
<h3 id="1-6-加载ELF格式的UcoreOS-kernel"><a href="#1-6-加载ELF格式的UcoreOS-kernel" class="headerlink" title="1.6 加载ELF格式的UcoreOS kernel"></a>1.6 加载ELF格式的UcoreOS kernel</h3><p><img src="https://i.loli.net/2021/11/27/GxE5IDwoWlvLTNH.jpg" alt="ELF Header"><br><img src="https://i.loli.net/2021/11/27/gY74vbBVue5Wm6L.jpg" alt="Program Header"><br>&amp;emsp;&amp;emsp;Bootloader第二件事就是加载Kernel。UcoreOS编译出来生成的是ELF格式的执行程序，ELF格式的执行程序是Linux里一个很常用的执行文件格式。ELF里面有个头叫ELF Header,ELF Header里面指出了一个Program Header,也就是程序段的头。程序段里面包含了代码段，数据段等等。比如上图中的代码，phoff这是程序段头的Offset，相当于ELF Header的偏移地址它的起始地址在什么地方。以及它的个数phnum，有了这两个信息就可以进一步去查找Program Header这个结构,把这个结构的信息去读出来，比如它的虚地址(va)要往哪个内存地址放，它的起始位置在什么地方，如果程序段是代码段，它的代码段要多大(memsz)。va和memsz这两个信息可以便于把内存中的相应一块区域用来存放代码段或者数据段等等。那么从这个文件的哪个位置开始读呢？offset指出了从文件的哪个位置把段给读进来。</p>
<p>&amp;emsp;&amp;emsp;大致就是说它能够识别出一些重要的关键信息，然后把相应的代码段、数据段从文件读到内存中来。还有它读的实际上是一个个连续的磁盘扇区，把它读到内存里面然后开始一个个进行分析工作。</p>
<hr>
<h2 id="实验前置理论-2-X86中断处理过程"><a href="#实验前置理论-2-X86中断处理过程" class="headerlink" title="实验前置理论-2 X86中断处理过程"></a>实验前置理论-2 X86中断处理过程</h2><h3 id="2-1-中断源"><a href="#2-1-中断源" class="headerlink" title="2.1 中断源"></a>2.1 中断源</h3><p><img src="https://i.loli.net/2021/11/28/m9fLMwp6cHxTIFk.jpg" alt="中断源"><br>&amp;emsp;&amp;emsp;这一部分一张图就够了。</p>
<hr>
<h3 id="2-2-确定中断服务例程-LSR"><a href="#2-2-确定中断服务例程-LSR" class="headerlink" title="2.2 确定中断服务例程(LSR)"></a>2.2 确定中断服务例程(LSR)</h3><p><img src="https://i.loli.net/2021/11/28/YfLtzcxWoiTClO5.jpg" alt="确定中断服务例程"><br>&amp;emsp;&amp;emsp;中断产生之后，操作系统需要理解这个中断需要做什么。无论是硬中断(外中断)，软中断(内中断)都和一个中断号有对应关系，而这个中断号唯一标识了这个中断的特征。对于每一个中断号呢，都有一个中断处理相应的例程来完成对应操作，这是OS需要去建立好的。</p>
<p>&amp;emsp;&amp;emsp;每一个中断或异常都与一个中断服务例程(Interrupt Service Routine)相关联，这个关联的建立是OS需要去考虑和实现的。我们需要去完成相应的处理过程，但这个处理过程又和具体硬件是相关的，所以说我们需要去了解在X86环境下怎么完成关联的建立。</p>
<p>&amp;emsp;&amp;emsp;上图中可以看到，在X86环境中它有一系列硬件机制支持这种对应关系的建立。它有一个IDT，也就是中断描述符表，跟GDT很类似，只是它专门用来描述中断的。这也是个大数组，然后里面的每项我们称为中断门或陷阱门(文章之后用中断门表示)。每个中断门对应着一个中断号，一个中断号可以有一个Index，我们根据这个中断号可以找到它对应的中断门，然后基于中断门可以进一步获取到跟这个中断门相关的段选择址。我们前面讲的段机制里有段的选择址和段内的偏移量，有了这两个信息就可以知道一个中断服务例程的地址。所以IDT和GDT合在一起，就可以完成中断或者是异常和中断服务例程对应的链接关系的建立。</p>
<p><img src="https://i.loli.net/2021/11/28/l8bUWZBHVXgoRyz.jpg" alt="中断门格式"><br>&amp;emsp;&amp;emsp;IDT表有一个起始地址和大小，保存在IDTR寄存器里。IDT表里的每一项中断门有它的格式，这里面最主要的两个，一个是段描述符，第二个是它的offset，有了这两个信息其实它的中断服务例程地址也就知道了。</p>
<p><img src="https://i.loli.net/2021/11/28/ZYpxn7mr8wyT4Wt.jpg" alt="确定中断服务例展示图"><br>&amp;emsp;&amp;emsp;产生了一个中断之后，根据这个中断我们可以知道它的中断号，CPU会根据中断号查询IDT找到它的中断门，然后从中断门取出它的段选择址，以这个选择址作为Index查找进一步查找GDT&#x2F;LDT得到段描述符。段描述符里有基址(Base address)，再加上中断门里保存的offset，合在一起就形成了相应的线性地址，从而可以指向ISR(中断服务例程)。所以说一旦产生了某个中断，CPU可以自动地在硬件这个层面访问IDT和GDT&#x2F;LDT这两个表，注意这两个表是OS建立好的，一旦建立好之后，CPU就可以基于这两个表查到中断对应的中断服务例程。当然这个例程也是由OS实现的，这样可以确保一旦产生了某一个中断之后，我们的OS可以及时地相应，去调用相应的函数做出处理。这就是中断处理的一个初始化过程。</p>
<hr>
<h3 id="2-3-切换到中断服务例程"><a href="#2-3-切换到中断服务例程" class="headerlink" title="2.3 切换到中断服务例程"></a>2.3 切换到中断服务例程</h3><p><img src="https://i.loli.net/2021/11/28/39eSF1EpyMu7ULP.jpg" alt="不同特权级的中断切换对堆栈的影响"><br>&amp;emsp;&amp;emsp;在中断之后，中断会打断当前正在执行的程序，然后去执行刚才所说的中断服务例程，中断服务例程执行完毕之后，再返回到当前被打断的程序中去继续执行这个程序。那么这有一个打断和恢复，这个恢复就需要保存。在上一篇介绍原理的文章说到，在不同的特权级它的处理方式是不一样的，特权级在段描述符里可以看到。段描述符里会设定它在哪一个特权级，比如说CS低两位，如果低两位是0，那么就处于内核态；而如果是3(十进制)代表运行在用户态。在内核态产生的中断依然在内核态，但是在用户态产生的中断也会跳到内核态里执行，这是两种不同的方式，因为这里产生了特权级的变化。对于这个特权级变和没变，中断的保存与恢复也是不一样的。</p>
<p>&amp;emsp;&amp;emsp;上图中左边是说内核态产生中断之后会发生什么变化。可以看到它还是用同一个栈，没有发生变化，只是在这个栈上压了一些被打断一刻的寄存器内容。第一个是有Error Code，这个Error Code代表是特意的严重异常，不是每一个中断或异常都会产生Error Code。第二个会压入EIP和CS，是当前被打断的那个地址或者被打断的下一条地址。第三个是Eflags，当前被打断的标志性的内容。这些是中断时由硬件自动压栈的内容，可以看到都压在同一个栈里面。</p>
<p>&amp;emsp;&amp;emsp;图中右边说的是当发生中断的时候产生不同特权级，意味着产生中断那一刻，应用程序正在用户态执行。我们可以看到第一点，从用户态到内核态它们用的是不同的栈，所以说当特权级变化产生中断之后呢，那么它除了压那些寄存器内容之外，还有很重要的两个信息是ESP和SS。实际上这两个内容是当时产生中断的时候，在用户态里的栈的地址。很明显在执行完毕恢复的时候，对于特权级没有发生变化的情况而言，它还是恢复到同一个特权级，还是在同一个栈里继续向下走。而对于特权级变化的这个情况而言，它会恢复到用户态去执行，不会用内核态去进一步执行。</p>
<p><img src="https://i.loli.net/2021/11/28/4ixhgDj6XBLHWkE.jpg" alt="返回指令"><br>&amp;emsp;&amp;emsp;当x86完成中断处理例程之后，还需要返回到被打断的程序继续执行。这里面对于中断服务例程来说，它会通过一个iret指令完成这个返回。但对于通常程序来说，它是通过ret和retf完成函数的返回，也意味着它们的处理方式是不一样的。对于没有改变特权级的方式，它其实是在同一个栈里把Error Code弹出，根据CS和EIP来跳到被打断的那个地方继续执行，同时还要恢复它的Eflags的值。而如果是改变特权级的方式，它还会把SS和ESP弹出，这是iret返回时要干的事情。对于ret而言，它只是弹出了EIP，也就是跳到当前的下一条指令去执行，而对于retf而言，弹出的是CS和EIP，也就是恢复CS，相当于完成一个远程跳转。</p>
<p>&amp;emsp;&amp;emsp;以上这些指令还只是硬件完成的工作，如果在中断服务例程中对其他寄存器进行修改的话，在修改前需要把寄存器的内容保存起来，在iret返回前恢复回来，从而确保跳回到被中断的应用程序时可以正确执行。</p>
<hr>
<h3 id="2-4-中断处理-系统调用"><a href="#2-4-中断处理-系统调用" class="headerlink" title="2.4 中断处理-系统调用"></a>2.4 中断处理-系统调用</h3><p><img src="https://i.loli.net/2021/11/28/oWxmO7YHRajJdt2.jpg" alt="中断处理-系统调用"><br>&amp;emsp;&amp;emsp;系统调用其实可以理解为一种特殊的中断，它称为trap(陷入)，或者说软中断。应用程序通过系统调用访问OS内核服务，从具体实践上说，系统调用机制的建立和中断机制建立时很接近的。在实践上需要考虑，如何指定中断号，如何完成从用户态到内核态的切换，以及从内核态回到用户态去，这一块有一些特殊的方法，或者是通过一些特殊指令可以完成相应的工作。在Ucore用的还是传统的嵌入方式，比如int 80这种通过软中断的方式来完成系统调用。但是为了完成系统调用，需要在建立IDT的时候对此特殊考虑。这跟其他的中断处理方式不太一样，因为这里很明确地指出了从用户态执行int 80或者int 某一个数能够从用户态切换到内核态，它有一个低优先级到高优先级的转变，这个机制需要在IDT表里设置相应的权限，才能完成这种转变。</p>
<hr>
<h2 id="3-Lab-1-编程实验"><a href="#3-Lab-1-编程实验" class="headerlink" title="3.Lab-1 编程实验"></a>3.Lab-1 编程实验</h2><h3 id="3-1-实现函数调用堆栈跟踪函数"><a href="#3-1-实现函数调用堆栈跟踪函数" class="headerlink" title="3.1 实现函数调用堆栈跟踪函数"></a>3.1 实现函数调用堆栈跟踪函数</h3><p>&amp;emsp;&amp;emsp;我们需要在lab1中完成kdebug.c中函数print_stackframe的实现，可以通过函数print_stackframe来跟踪函数调用堆栈中记录的返回地址。在如果能够正确实现此函数，可在lab1中执行 “make qemu”后，在qemu模拟器中得到类似如下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ebp:0x00007b28 eip:0x00100992 args:0x00010094 0x00010094 0x00007b58 0x00100096</span><br><span class="line">    kern/debug/kdebug.c:305: print_stackframe+22</span><br><span class="line">ebp:0x00007b38 eip:0x00100c79 args:0x00000000 0x00000000 0x00000000 0x00007ba8</span><br><span class="line">    kern/debug/kmonitor.c:125: mon_backtrace+10</span><br><span class="line">ebp:0x00007b58 eip:0x00100096 args:0x00000000 0x00007b80 0xffff0000 0x00007b84</span><br><span class="line">    kern/init/init.c:48: grade_backtrace2+33</span><br><span class="line">ebp:0x00007b78 eip:0x001000bf args:0x00000000 0xffff0000 0x00007ba4 0x00000029</span><br><span class="line">    kern/init/init.c:53: grade_backtrace1+38</span><br><span class="line">ebp:0x00007b98 eip:0x001000dd args:0x00000000 0x00100000 0xffff0000 0x0000001d</span><br><span class="line">    kern/init/init.c:58: grade_backtrace0+23</span><br><span class="line">ebp:0x00007bb8 eip:0x00100102 args:0x0010353c 0x00103520 0x00001308 0x00000000</span><br><span class="line">    kern/init/init.c:63: grade_backtrace+34</span><br><span class="line">ebp:0x00007be8 eip:0x00100059 args:0x00000000 0x00000000 0x00000000 0x00007c53</span><br><span class="line">    kern/init/init.c:28: kern_init+88</span><br><span class="line">ebp:0x00007bf8 eip:0x00007d73 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8</span><br><span class="line">&lt;unknow&gt;: -- 0x00007d72 –</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;请完成实验，看看输出是否与上述显示大致一致，并解释最后一行各个数值的含义。</p>
<p>&amp;emsp;&amp;emsp;以上是实验作业要求，以下是完成的代码，在注释里写了代码的意思。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_stackframe</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//这部分英文注释为源代码中的英文提示</span></span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span>	</span><br><span class="line">    <span class="comment">//ebp_v和eip_v分别通过调用read_ebp,read_eip函数获得ebp,eip寄存器的值。</span></span><br><span class="line">	<span class="type">uint32_t</span> ebp_v=read_ebp();</span><br><span class="line">	<span class="type">uint32_t</span> eip_v=read_eip();</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这里的宏STACKFRAME_DEPTH为20</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;ebp_v!=<span class="number">0</span> &amp;&amp; i&lt; STACKFRAME_DEPTH; i++)&#123;</span><br><span class="line">    <span class="comment">//首先将ebp和eip的值以0x%08x的格式打印在显示器上</span></span><br><span class="line">    <span class="comment">//%08x为显示8位并会自动在前面补0的十六进制数</span></span><br><span class="line">		cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>,ebp_v,eip_v);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//连续打印四个参数，第一个参数位置在当前ebp+8</span></span><br><span class="line">      <span class="comment">//这里因为是uint_32t，size为4个字节，所以+2也就是ebp+8</span></span><br><span class="line">		<span class="type">uint32_t</span> *args=(<span class="type">uint32_t</span>*)ebp_v+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">			cprintf(<span class="string">&quot;0x%08x &quot;</span>,args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		print_debuginfo(eip_v<span class="number">-1</span>);<span class="comment">//输出C函数的行号和函数名等信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新eip_v和ebp_v使它们指向函数调用者，调用者eip压栈时保存</span></span><br><span class="line">    <span class="comment">//在ebp+4中，而调用者ebp保存在当前ebp中，具体可以看看函数堆</span></span><br><span class="line">    <span class="comment">//栈的相关知识</span></span><br><span class="line">		eip_v=((<span class="type">uint32_t</span>*)ebp_v)[<span class="number">1</span>];</span><br><span class="line">		ebp_v=((<span class="type">uint32_t</span>*)ebp_v)[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附：Ucore实验指导书中函数堆栈相关内容：<a target="_blank" rel="noopener" href="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_3_1_function_stack.html">https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_3_3_1_function_stack.html</a> </p>
<hr>
<h3 id="3-2-完善中断初始化和处理"><a href="#3-2-完善中断初始化和处理" class="headerlink" title="3.2 完善中断初始化和处理"></a>3.2 完善中断初始化和处理</h3><p>&amp;emsp;&amp;emsp;请完成编码工作和回答如下问题：</p>
<p>&amp;emsp;&amp;emsp;1.中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</p>
<p>&amp;emsp;&amp;emsp;2.请编程完善kern&#x2F;trap&#x2F;trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools&#x2F;vectors.c生成，使用trap.c中声明的vectors数组即可。</p>
<p>&amp;emsp;&amp;emsp;3.请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p>
<p>&amp;emsp;&amp;emsp;先解决第一个问题，从源代码中可以找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Gate descriptors for interrupts and traps */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> gd_off_15_0 : <span class="number">16</span>;        <span class="comment">// low 16 bits of offset in segment</span></span><br><span class="line">    <span class="type">unsigned</span> gd_ss : <span class="number">16</span>;            <span class="comment">// segment selector</span></span><br><span class="line">    <span class="type">unsigned</span> gd_args : <span class="number">5</span>;            <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line">    <span class="type">unsigned</span> gd_rsv1 : <span class="number">3</span>;            <span class="comment">// reserved(should be zero I guess)</span></span><br><span class="line">    <span class="type">unsigned</span> gd_type : <span class="number">4</span>;            <span class="comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span></span><br><span class="line">    <span class="type">unsigned</span> gd_s : <span class="number">1</span>;                <span class="comment">// must be 0 (system)</span></span><br><span class="line">    <span class="type">unsigned</span> gd_dpl : <span class="number">2</span>;            <span class="comment">// descriptor(meaning new) privilege level</span></span><br><span class="line">    <span class="type">unsigned</span> gd_p : <span class="number">1</span>;                <span class="comment">// Present</span></span><br><span class="line">    <span class="type">unsigned</span> gd_off_31_16 : <span class="number">16</span>;        <span class="comment">// high bits of offset in segment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  &amp;emsp;&amp;emsp;根据代码得到一个描述符中所有的bit相加共有64个，也就是64字节。gd_ss(16)加上gd_off(共32)，也就是段选择符加上偏移量一共48位代表中断处理代码的入口。</p>
<p>  &amp;emsp;&amp;emsp;第二题为初始化建立IDT(中断描述符表&#x2F;中断向量表)的函数，有关代码如下：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="type">void</span> <span class="title function_">idt_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 2 */</span></span><br><span class="line">     <span class="comment">/* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?</span></span><br><span class="line"><span class="comment">      *     All ISR&#x27;s entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?</span></span><br><span class="line"><span class="comment">      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c</span></span><br><span class="line"><span class="comment">      *     (try &quot;make&quot; command in lab1, then you will find vector.S in kern/trap DIR)</span></span><br><span class="line"><span class="comment">      *     You can use  &quot;extern uintptr_t __vectors[];&quot; to define this extern variable which will be used later.</span></span><br><span class="line"><span class="comment">      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).</span></span><br><span class="line"><span class="comment">      *     Can you see idt[256] in this file? Yes, it&#x27;s IDT! you can use SETGATE macro to setup each item of IDT</span></span><br><span class="line"><span class="comment">      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using &#x27;lidt&#x27; instruction.</span></span><br><span class="line"><span class="comment">      *     You don&#x27;t know the meaning of this instruction? just google it! and check the libs/x86.h to know more.</span></span><br><span class="line"><span class="comment">      *     Notice: the argument of lidt is idt_pd. try to find it!</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*#define SETGATE(gate, istrap, sel, off, dpl) &#123;            </span></span><br><span class="line"><span class="comment">		(gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff;        </span></span><br><span class="line"><span class="comment">		(gate).gd_ss = (sel);                                </span></span><br><span class="line"><span class="comment">		(gate).gd_args = 0;                                    </span></span><br><span class="line"><span class="comment">		(gate).gd_rsv1 = 0;                                    </span></span><br><span class="line"><span class="comment">		(gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    </span></span><br><span class="line"><span class="comment">		(gate).gd_s = 0;                                    </span></span><br><span class="line"><span class="comment">		(gate).gd_dpl = (dpl);                                </span></span><br><span class="line"><span class="comment">		(gate).gd_p = 1;                                    </span></span><br><span class="line"><span class="comment">		(gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;        </span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有关中断服务例程入口的地址已经保存在了__vectors[]中</span></span><br><span class="line">     <span class="keyword">extern</span> <span class="type">uintptr_t</span> __vectors[];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//循环的次数为idt表的大小/单个中断门的大小</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> gatedesc) ; i++)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*第一个参数是要写入的idt表位置，第二个参数中断门设置为0，</span></span><br><span class="line"><span class="comment">    系统段设置为1，第三个参数为段选择符内容，第四个参数为</span></span><br><span class="line"><span class="comment">    偏移量，这里为__vector中的内容，最后一个参数为优先级，</span></span><br><span class="line"><span class="comment">    DPL_KERNEL为0，也就是最高的特权级0*/</span></span><br><span class="line">		SETGATE(idt[i],<span class="number">0</span>,GD_KTEXT,__vectors[i],DPL_KERNEL);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//为从用户切换到内核而设置</span></span><br><span class="line">  SETGATE(idt[T_SWITCH_TOK],<span class="number">0</span>,GD_KTEXT,__vectors[T_SWITCH_TOK],DPL_USER);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用lidt函数(原函数实际上是一个汇编指令)，让CPU知道IDT在什么</span></span><br><span class="line">  <span class="comment">//地方，从而完成IDT的加载。idt_pd是它的起始地址。</span></span><br><span class="line">  <span class="comment">/*static struct pseudodesc idt_pd = &#123;</span></span><br><span class="line"><span class="comment">    sizeof(idt) - 1, (uintptr_t)idt</span></span><br><span class="line"><span class="comment">  &#125;;*/</span></span><br><span class="line">  </span><br><span class="line">  lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  &amp;emsp;&amp;emsp;第三题只是完成100次时钟中断后就显示100 ticks之类的信息，这就简单了，直接上代码叭：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//这里代码仅是trap_dispatch的一部分</span></span><br><span class="line">  <span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        <span class="comment">/* LAB1 YOUR CODE : STEP 3 */</span></span><br><span class="line">        <span class="comment">/* handle the timer interrupt */</span></span><br><span class="line">        <span class="comment">/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c</span></span><br><span class="line"><span class="comment">         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</span></span><br><span class="line"><span class="comment">         * (3) Too Simple? Yes, I think so!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    	ticks++;</span><br><span class="line">      <span class="comment">//TICK_NUM = 100</span></span><br><span class="line">    	<span class="keyword">if</span>(ticks%TICK_NUM==<span class="number">0</span>)&#123;</span><br><span class="line">    		print_ticks();</span><br><span class="line">    	&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><img src="https://i.loli.net/2021/11/30/cHgbhdS5sPprmu1.jpg" alt="运行效果"></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&amp;emsp;&amp;emsp;花了两天晚上总算是做完了第一个lab，别看代码短，但是真的好难。。。做这个lab的感觉就是在玩解密游戏，要到各个相关联的文件里的代码找线索，最后才能写出正确的代码，OS真是挺有趣也挺有挑战性的。最近因为要准备期末考了估计OS学习得搁置了，希望接下来能抓紧补下去。我认为计算机基础课学好了还是对自身的发展有很大帮助的，给自己加油🍭🍭</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">Jiang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/30/os_study_4/">http://example.com/2021/11/30/os_study_4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/">操作系统实验</a></div><div class="post_share"><div class="social-share" data-image="/img/AVA.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/10/unitystu__3/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/AVA.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">从零开始独立游戏开发学习笔记（三） -- Unity基础（二）</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/22/os_study_3/"><img class="next-cover" src="/img/WIF2.png" onerror="onerror=null;src='/img/AVA.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">THU《操作系统》学习笔记——原理2： 启动、中断、异常和系统调用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/11/21/os_study_2/" title="THU《操作系统》学习笔记——实验0 操作系统实验环境准备和x86-32硬件介绍"><img class="cover" src="/img/WIF2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-21</div><div class="title">THU《操作系统》学习笔记——实验0 操作系统实验环境准备和x86-32硬件介绍</div></div></a></div><div><a href="/2022/04/16/os_study_7/" title="THU《操作系统》学习笔记——实验2：物理内存管理"><img class="cover" src="/true" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-16</div><div class="title">THU《操作系统》学习笔记——实验2：物理内存管理</div></div></a></div><div><a href="/2021/11/19/os_study_1/" title="THU《操作系统》学习笔记——原理1：操作系统概述"><img class="cover" src="/img/WIF2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-19</div><div class="title">THU《操作系统》学习笔记——原理1：操作系统概述</div></div></a></div><div><a href="/2021/11/22/os_study_3/" title="THU《操作系统》学习笔记——原理2： 启动、中断、异常和系统调用"><img class="cover" src="/img/WIF2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-22</div><div class="title">THU《操作系统》学习笔记——原理2： 启动、中断、异常和系统调用</div></div></a></div><div><a href="/2022/03/27/os_study_6/" title="THU《操作系统》学习笔记——原理4：物理内存管理：非连续内存分配"><img class="cover" src="/img/WIF2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-27</div><div class="title">THU《操作系统》学习笔记——原理4：物理内存管理：非连续内存分配</div></div></a></div><div><a href="/2022/03/20/os_study_5/" title="THU《操作系统》学习笔记——原理3：物理内存管理：连续内存分配"><img class="cover" src="/img/WIF2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-20</div><div class="title">THU《操作系统》学习笔记——原理3：物理内存管理：连续内存分配</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/AVA.jpg" onerror="this.onerror=null;this.src='/img/AVA.jpg'" alt="avatar"/></div><div class="author-info__name">Jiang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#THU%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94-%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9Abootloader%E5%90%AF%E5%8A%A8ucoreos"><span class="toc-number">1.</span> <span class="toc-text">THU《操作系统》学习笔记—— 实验一：bootloader启动ucoreos</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%89%8D%E7%BD%AE%E7%90%86%E8%AE%BA-1-%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">实验前置理论-1 启动顺序：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-x86%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 x86寄存器初始值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%A4%84%E4%BA%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%AE%B5"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 处于实模式的段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%BB%8EBIOS%E5%88%B0Bootloader"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 从BIOS到Bootloader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E4%BB%8EBootloader%E5%88%B0OS"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 从Bootloader到OS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 段机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%8A%A0%E8%BD%BDELF%E6%A0%BC%E5%BC%8F%E7%9A%84UcoreOS-kernel"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 加载ELF格式的UcoreOS kernel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%89%8D%E7%BD%AE%E7%90%86%E8%AE%BA-2-X86%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">实验前置理论-2 X86中断处理过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%AD%E6%96%AD%E6%BA%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 中断源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%A1%AE%E5%AE%9A%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B-LSR"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 确定中断服务例程(LSR)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%87%E6%8D%A2%E5%88%B0%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 切换到中断服务例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 中断处理-系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Lab-1-%E7%BC%96%E7%A8%8B%E5%AE%9E%E9%AA%8C"><span class="toc-number">1.3.</span> <span class="toc-text">3.Lab-1 编程实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 实现函数调用堆栈跟踪函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AE%8C%E5%96%84%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A4%84%E7%90%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 完善中断初始化和处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/15/unitystu__4%20-%20%E5%89%AF%E6%9C%AC/" title="面谈个人简介">面谈个人简介</a><time datetime="2022-05-15T12:12:02.000Z" title="Created 2022-05-15 20:12:02">2022-05-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/15/GoldFlake_2/" title="GoldFlake：API使用文档">GoldFlake：API使用文档</a><time datetime="2022-05-15T02:10:35.000Z" title="Created 2022-05-15 10:10:35">2022-05-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/12/GoldFlake/" title="GoldFlake：与竞争对手斗智斗勇！突发奇想的非连续时间戳雪花算法版本！">GoldFlake：与竞争对手斗智斗勇！突发奇想的非连续时间戳雪花算法版本！</a><time datetime="2022-05-11T16:00:35.000Z" title="Created 2022-05-12 00:00:35">2022-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/04/21/redis-study-6/" title="Redis学习笔记（6）：zset类型API大全(Redis 7.0)">Redis学习笔记（6）：zset类型API大全(Redis 7.0)</a><time datetime="2022-04-21T12:00:35.000Z" title="Created 2022-04-21 20:00:35">2022-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/04/16/os_study_7/" title="THU《操作系统》学习笔记——实验2：物理内存管理">THU《操作系统》学习笔记——实验2：物理内存管理</a><time datetime="2022-04-16T09:12:31.000Z" title="Created 2022-04-16 17:12:31">2022-04-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Jiang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>